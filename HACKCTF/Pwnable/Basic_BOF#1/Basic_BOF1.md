## 사전지식    
이문제는 포너블의 처음 문제이므로   
아마 IDA라는 프로그램으로 뜯어 풀었을 텐데   
거기에 나오는 ESP라든가, ECX, EBP...   
모르는 용어들이 많이 나와서 한 번 짚어주는게 좋을 것 같아 짚어 주도록 하겠다.   
![프로그래밍메모리구조](/HACKCTF/Pwnable/Basic_BOF%231/프로그래밍메모리구조.PNG)    
일단 위 사진을 보면서 설명일 이어가자면   
우리가 프로그램을 실행할 때 운영체제에서 필요한 메모리 공간을 제공하는데,   
1. 코드영역    
2. 데이터 영역   
3. 스택 영역    
4. 힙 영역    
으로 나누게 된다.   

### 1. 코드영역    
말 그대로 우리가 적은, 실행될 코드들이 저장될 영역이다.   
### 2. 데이터 영역    
프로그램 실행 시 필요한, 우리가 코드내에서 선언한   
전역 및 정적 변수가 저장되는 영역이다.   
IDA에서도 변수들은 다 맨 위에 선언이 되있는 모습이 보일 거다.    
### 3. 스택 영역   
함수 호출시 할당되는 영역이다.   
이 부분은 함수 호출이 완료되면(return)자동 소멸되는 영역이다.   
main도 함수이기 때문에 스택영역에 저장된다.    
* 그리고 스택영역은 높은 주소 -> 낮은 주소 방향으로 할당된다.     
### 4. 힙 영역    
간단하게 설명하면 동적할당한 메모리의 영역으로,   
사용자가 직접 관리하는 메모리 영역이다.   
* 그리고 힙영역은 낮은 주소 -> 높은 주소 방향으로 할당된다.    
***
이 정도면 대충 프로그램 실행시 어떤 방식으로 메모리가 할당되는지 알게 됐을 것이다.   
우리는 여기서 main함수를 중점적으로 보기 때문에 스택영역을 봐야 하는데,   
일단 IDA를 보면서 필요한 부분만 여기에 적어두겠다. 나머지는 링크를 달아둘테니 스스로 공부하도록.    
### 스택 레지스터 
레지스터는 컴구시간에 배웠으니 뭔지 알려나..?    
>  레지스터는 간단히 설명하면 컴퓨터와 프로세서 내에서 자료를 보관하는 메모리 중 하나로, 그 속도가 아주 빠른 대신 용량이 많지는 않다.    
>  사용 용도에 따라 범용, 포인터, 플래그 레지스터로 나뉜다.    
이떄 스택에서 사용하는 레지스터는 2가지가 있는데,   
**ESP** 와 **EBP** 이다.   
간단하게 설명하면 ESP는 스택의 맨 위(=스택의 크기), EBP는 스택의 가장 밑 주소를 저장하고 있는 레지스터다.   
위에서 봤듯이 스택은 차곡차곡 쌓이는 형태의 메모리다. 그럼 어떻게 되겠는가?    
그렇다. ESP의 주소는 계속 변하고, EBP의 주소는 변하지 않는다.    
ESP는 PUSH, POP, SUB등 명령들을 수행할 때마다 바뀐다.   
하지만 EBP는 위치가 고정적이기 때문에 보통 변수의 위치를 찾을 때 EBP레지스터를 사용한다.   

아 추가로 아까 위에서 설명했듯 스택영역은 높은주소->낮은주소 로 되어있기 때문에    
ESP의 값이 줄어들면 메모리공간이 늘어가는 거다.   


## 풀이    
자 일단 IDA로 까보면   
![IDAVIEW](/HACKCTF/Pwnable/Basic_BOF%231/IDAview.PNG)   
>  물론 코드에 주석으로 ebp esp값이 적혀있긴 하나 아무래도 실제 코드값으로 보는게 더 정확하지 않을 까 싶다.   
일단 s는 -34에 위치해 있다고 하니 ebp-34이고, v5는 이제 코드를 보면 이해가 갈 텐데    
![pseudocode](/HACKCTF/Pwnable/Basic_BOF%231/pseudocode.PNG)   
main에서 나오는 v5는 IDAview로 봤을 때 계속해서 var_C가 나오는 거보면 var_C = v5라는 걸 유츄할 수 있다.   
v5는 -0C에 위치해 있다고 하니 ebp-C이네.   
그럼 이해가 되게 그림으로 그려 보겠다.    
![스택메모리구조](/HACKCTF/Pwnable/Basic_BOF%231/stack.PNG)  
차근차근 설명 해주자면 일단 ret와 sfp라는 처음보는 단어들이 나와 당황스러울 텐데,   
ret는 말그래도 return, 함수의 끝이고, sfp는 이전 함수의 ebp를 저장하는 공간이다.   
함수의 경우 함수의 주소로 이동했다가 다시 돌아와야 하기 때문에 이전 함수의 ebp를 저장해놓는 것.   
쩃든, ebp를 기준으로 0x34위치에 s가 1byte만큼 있고, 0xC에 v5가 4byte의 크기만큼 있다.   
그리고 코드를 보면 v5가 -559038737, hex로 0xDEADBEEF가 채워지면 쉘권한을 딸 수 있다.   
그럼 s에서 BOF를 일으켜야 하는데, 얼마만큼 BOF를 일으켜야 하는 걸까?   
감이 좋은 친구들은 알아채렸겠지만, s와 v5의 거리를 구해서 그만큼 BOF를 일으키면 되는 것이다.   
거리를 구하는 건 간단하다! 그림을 보면 알겠지만 그냥 s거리에서 v5만큼 뺴면된다.    
0x34 - 0xC = 0x28 = 40byte의 사이공간이 있다.   
이제 구할 건 다 구했다!   
fgets도 45만큼 입력받으니 충분히 입력할 수 있다.   
GOOD LUCK!